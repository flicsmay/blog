##查询系统的实现

这个查询系统是第四章最后一个程序了，作者也花了很大篇幅去说明这个程序。（但是个人感觉这个程序有很多各种各样的问题，不过用来研究逻辑程序设计还是好的）

~~（不过个人认为这次是作者讲的比较清楚的一次了，至少是从第四章以来，但感觉翻译有点误导性，还是推荐看英文教材）~~

在往下看之前推荐将4.4.2节多看几遍，说不定就不用再看我写的东西了。传送门： [4.4.2(eng)](https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_sec_4.4.2)

顺便提一句，以下是在我还没看数据库原理之前写的，如有错误，请见谅。

####分析

当我们想要去完成一个数据库时，我们应该想到要去完成其储藏、分析、提取的功能。不过毕竟我还不懂数据库，就先按照着给我们的数据库的例子来分析吧。（毕竟这也离真正的数据库差个十万八千里吧。。）

对于最简陋版的数据库：

* 数据保存、存放的功能
* 数据查询的功能（通过某种方法取出想要的数据）

以上的这两条都很容易实现，链表和遍历就是最简单的一种组合。

对于像书上的这种数据库只是在查询方面有了改进，书上对数据库支持了模式查询，还有制定规则：

* 对于输入的模式进行分析
* 检查一条记录是否符合这条模式
* 对于制定的规则进行分析、储存

不过也正如书上的4.4节的标题说的，这个程序是告诉我们逻辑程序是怎么样的，貌似他也做到了，那下面就是这个程序的分析

####逻辑

这个程序从全局上来看可以被当成一个框架流的处理程序。框架、我们前面也见到很多次了，就是一个环境的约束集，其中保留着环境中（部分）变量的约束，当然这和这次的程序关系不大。这个程序的基本思想就是，将应用变量是否冲突加入到模式匹配的检查中，还有将传递框架转化成框架的流。

当你要检查一个模式是否匹配时，就是将 **给定的一个框架扩充** ，如果这个扩充没有造成冲突的话，就说明这个扩充是可行的。若是造成冲突的话，那么这个扩充是失败的。

将书上描述过的例子搬过来，若是用模式 `(?x ?y ?x)` 去匹配 `(a b a)` 给予不同的框架结果会不同。若是一个空框架，那么很明显的返回一个框架，其中` ?x -> a , ?y -> b ` ，这是一个成功的返回。不过若是给定的框架中原本就有 `?x -> b` 或者 `?y -> a` 的约束，那么会与现在的匹配冲突，返回一个错误。不过若是其中有 `?x -> a` 或者 `?y -> b` 或两者，框架就会被扩充。

为什么要这样子做呢？因为你要对模式进行匹配。其中 **已经匹配好的模式是必须要记住的** ，比如你在先前的某个地方将 `?x` 与某个实例匹配了，你就要分辨 `?x` 是否能与给定的另外一个变量匹配。

还有很重要一点就是这个流的分析是分段式的。比如说你要求一个断言 `(and <exp0> <exp1> ... <expn>)` ，你是先用空框架对 `<exp0>` 进行匹配，匹配出的结果（含有约束的框架）发送给 `<exp1>` 进行二次匹配，这样依次下去直到过程体完结（`<expn>`)。在这过程中你得想办法保留之前匹配的结果，才能保证结果是正确的。

前面也说了，模式匹配是需要将全部符合的条目筛选出来的，那么怎么用框架完成这个任务呢。这里作者用的是框架流，一种很聪明的想法。就是对于每一个框架，抓取合适的断言（或许是所有的），和合适的规则对这个规则进行匹配，上面也提到每一次成功的匹配都会生成一个框架（这里失败的话是不生成框架）。于是，这样就会 **生成两个流** ，不过这两个流本质上都是对现有框架的扩充，随后就可以用合并成同一个流。

所以，对于每个输入一个匹配器（也就是进行匹配）的框架，匹配器都会生成一个对这个框架扩充的流。（也就是说 **匹配成功** 扩充的结果，失败的话不会返回框架）所以，对于多重的匹配（比如说 `<pro: and>` ）就会想一条流水线一样，用第一个框架匹配生成的流（总共 **n个框架** ），去应用第二个匹配器。然后生成 **n个流** ，以此类推。

所以由上面可以知道，假设 `<pro: and>` 一共有k条语句，每次遍历一同要经过n条断言。  **`<pro: and>` 的时间复杂度为 O(n^k)。** （练习4.76中有办法优化 *and* 语句）

####逻辑程序设计

对于这个逻辑程序设计 [【4.4.3】](https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_sec_4.4.3) 中已经讲的很好了，逻辑程序设计就是将语句设计成逻辑流的形式。在这里看是 `<pro: and>/<pro: or>/<pro: not>` ， `<pro: and>` 将结果串行处理，`<pro: or>` 则是并行。其中 `<pro: not>` 更像是一种过滤器，书上也说了，就不赘述了。

####程序主体分析

其实我在前面几节分析程序的时候都出现了很大的问题，就是我应该把程序看作一种更加抽象的事物。（应该来说是像黑盒子一样看）应该更加关注程序的思路和功能，而不是去抓住细节不放。在这本书里面作者已经构造出非常优美的抽象了，通过构造的抽象看程序会无比清晰。 ~~（果然智商低学什么都有问题，sign）~~

#### *qeval*

那就从 *qeval* 开始吧，*qeval* 的作用是用给定的框架流和查询模式进行输入，然后返回这个符合这个模式的框架流。（从数据库查询）这里选择将数据流作为一个整体往下派送，并用 *get* 函数来查询复杂过程，并在后面选择复杂过程或者简单过程。
	
	(define (qeval query frame-stream)
	   (let ((qproc (get (type query) 'qeval)))
	     (if qproc
	         (qproc (contents query) frame-stream)
	         (simple-query query frame-stream))))

为什么这里用 *get* 过程而前面的求值器中的 *eval* 没有用呢？个人认为是这样：对 *eval* 那么多分配过程如果用了分配查询，就会让过程体里面不知道发生了什么事，找起来困难， *eval* 将分支全部列出来也不会显得臃肿。这里如果不用 *get* 就会多写出几个 *if* 语句，写了反而会更加清晰、明了。

既然得到了符合一个模式的框架了，就要想办法将其打印出来，因为拿到的只是一个变量和值的约束集。所以还需要想办法将模式在这个框架中求值，也就是 **实例化** ，在这里就是将遇到的变量替换成对应的值就好了。值得一提的就是对于未绑定的变量的处理。这里单纯是将变量名转化成字符串然后输出就好。

之后就看到 *qeval* 函数体里面了，先说复杂过程， *conjoin* 和 *disjoin* 的接口和 *qeval* 的接口设计的非常精妙。拿 *conjoin* 来举例， *conjoin* 从上往下拿框架流给 *qeval* 生成扩充框架流交给下一个语句。 *disjoin* 则是直接合并流， *negated* 用 *if* 语句将空流截取返回原框架。

	(define (conjoin conjuncts frame-stream)
	   (if (empty-conjunction? conjuncts)
	       frame-stream
	       (conjoin (rest-conjuncts conjuncts)
	                (qeval (first-conjunct conjuncts)
	                       frame-stream))))

对于简单的查询，每个框架都递给两个过程进行查询 `<pro: find-assertions> / <pro: apply-rules>` 一个是查询断言的，一个是查询规则的。我之前对这个安排有着疑问，为什么要将同时输出断言和规则的流，用 *if* 判断不会更好吗？但其实这里用了 *fetch-rules* 和 *fetch-assertions* 来抓取所要的东西。

	(define (simple-query query-pattern frame-stream)
	   (stream-flatmap
	    (lambda (frame)
	      (stream-append-delayed
	       (find-assertions query-pattern frame)
	       (delay (apply-rules query-pattern frame))))
	    frame-stream))

这里就要说一下这个程序所用的储存机制了，他是根据断言或规则的 *car* 也就是第一个标志符来分配储存的。这样，在查找一条断言和规则时就可以根据输入的规则的 *car* 来查找了。

在得到两条输出流之后，就用 *stream-append* 合并成一条流，然后 *stream-flatmap* 将生成出来的流的流（也就是很多流）合并成一个流。（那个 *flatten-stream* 调用 *interleave-delayed* 把我搞晕了。。。就不分析了）

#### *pattern-match*

*assertions* 这边之后就是一直往下降，重要的部分是 *pattern-match* 。这个函数是将模式与数据匹配，失败返回 *fail* 然后上层收到后返回空流，成功的话就返回扩充后的框架，看到这种模式就应该意识到又要递归调用了。。。这个模式匹配的设计很巧妙，如果是复合过程匹配就将数据和模式一层一层往下降，同时扩充框架。当遇到变量时查找到的变量也可能是符合过程，这时就递归调用 *pattern-match* 来进行进一步匹配。

	(define (pattern-match pat dat frame)
	   (cond ((eq? frame 'failed) 'failed)
	         ((equal? pat dat) frame)
	         ((var? pat) (extend-if-consistent pat dat frame))
	         ((and (pair? pat) (pair? dat))
	          (pattern-match (cdr pat)
	                         (cdr dat)
	                         (pattern-match (car pat)
	                                        (car dat)
	                                        frame)))
	         (else 'failed)))

最后要说的就是 **规则和合一** 了，规则的应用中有一个很重要的地方就是改变量名，因为最外层是根据规则的名字 **实例化** 的，所以不能直接向规则应用参数，必须要在框架中扩充。再加上有规则嵌套规则的可能，所以为了防止冲突，为变量修改标识符是必要的。在这里调用了 *rename-variable-in* 这个函数对规则中的变量加上一个唯一的ID，这样就可以保证不和其他规则冲突。（过程很明了就不多说了）

在对变量名修改之后就可以对规则和结论(`conclution`)合一了，这里的合一和 *patten-march* 差不多，不过变量是对双方都成立的。

####总结

其实还有很多地方我是没有提到的，不过大多是细枝末节的过程。其实书上的过程已经是非常清晰了，有什么不清楚的地方看几遍书估计也没什么问题了。（其实就是我不想写了。。。好长）

这个程序给了我们一个流处理的实例，也是逻辑程序设计的实例。作者的构造很精妙， ~~感觉智商被碾压~~ 总之好的设计是值得我们去学习的。（啦啦啦，第五章我来啦）
