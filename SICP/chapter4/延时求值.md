##采用惰性求值的解释器
这里是将一个**应用序**的求值器转换为一个**正则序**的求值器。

* **应用序**： 在过程应用的时候，提供给 *scheme* 的所有**参数都必须要完成求值**。
* **正则序**： 可以吧对过程参数的求值延后到**需要这些实际参数的时候求值**。

*scheme* 语言本身是一个**应用序**的语言。

举一个很简单的例子，正如书上说的。

	(define (example a b)
	  (if (= a 1)
	      1
	      b))

	>(example 1 (infinitely-loop))

这里按照正常逻辑来说应该是返回1， *infinitely-loop* 过程是不应该被调用的。而在 **应用序** 的应用函数的过程中要对参数进行求值，就会陷入无限循环。而 **正则序** 的是在需要函数的时候求值，就不会陷入循环。

####分析
在这里我们要想让参数延迟求值，我们会想到第三章中的延迟 ~(至少我是只能想到这个，哭）~ 。第三章中描述的流过程就是延时求值，到需要一个表达式的值时才对那个表达式求值。在这里，作者确实也是这么做的。

要是延迟的话就会出现一个问题，该如何去应用这些过程，按照第三章的说法是：how to *force* it.有一种想法（不知道可不可行）就是添加 *eval* ，让其可以处理带 *delay* 标签的子句。不过，作者用的方法是使用槽（chunk）的方法，然后用 *force-it* 进行外套，对层层包装进行展开，然后求值。

要用延迟处理 *eval* 中 *apply* 子句中的 *list-of-value* 是不能要的，可以把这条语句替换成，`(delay (operands exp))` 作者在这里吧它细分到 *apply* 中去了，因为 *scheme* 内置的基础过程全部是 **严格的** ，这样可以节省许多的时间。

值得注意的几点是 *force-it* 是放在了 *eval* 的最外层，而 *actual-value* 确是放在了 *apply* 函数体内的各个地方。这大概是考虑到确定会用到参数具体值的情况，看看 *force-it* （也同样算上 *actual-value* ）所在的位置:

* `application?`:计算 *operator* ，过程的操作符必须计算
* `primitive-procedure?`: 计算基本过程，是必须全部求值的
* `eval-if`: 计算判断语句的值，同样是必须计算的
* 还有最外层的一个`actual-value`: 如名字所说，这里是要确保返回的是实际值

在这些位置都是需要强制求值的，可以看出， ***force-it* 过程只在必要的地方被调用**，在其他地方都延缓了求值（也就是不去求值，直到全部解释完成了，被外层的 *actual-value* 捕捉到的时候，才强制求值（如果还有的话））。这种机制就可以使参数最少的被求值的可能。

还有就是 *force-it* 的实现是调用了 *actual-value* ， *actual-value* 的实现如下：
	
	(define (actual-value exp env)
	  (force-it (eval exp env)))

可以看到， *force-it* 和 *actual-value* 是递归调用的关系，这可以保证即使里面包裹着很多层的 *delay* *actual-vaule* 都可以返回实际的值。

**记忆过程** ： 槽的设计是可以保存执行的值的，这样可以大大加速程序执行的过程。因为与前面不同，第一版的 *eval* 是将参数 **全部求值后再与变量绑定到环境中** 。而这版的 *eval* **不能在绑定变量之前求值** ，所以如果没有记忆过程的话，每次调用参数都需要重新求值变量一遍。这个求值用 *set!* 实现，用于改变变量约束。