##第四章总结

第四章是个非常有趣的章节，一共呢是写了四个求值器，以及一个看起来像求值器的查询系统。
 
* 4.1节，普通求值器
	* 4.17节，将语法分析分离开来
* 4.2节，惰性求值器
* 4.3节，amb求值器
* 4.4节，查询系统

在学习那么多求值器中，我看到了最重要的一点，就是 **抽象** 。虽然之前的章节中作者也一直在提到这个问题，但是这里是让我感受最深刻的。

比如说，最简单的 *eval* 过程，这个过程的作用就是给予一个表达式和环境变量，然后他给你这个求值的结果（一个值、一个过程等等）。单单看 *eval* 这个程序它完成了这个任务吗？他只是做了一个分配器的功能，将各种情况分配下去，它没完成吗？光从逻辑上来看 *eval* 这个程序一点问题都没有。而且我们会发现在被 *eval* 调用的子程序里面， **只要是涉及到对一个表达式求值的过程，全部都用 *eval* 完成** 。那么这样不就是无限循环了吗？这就是我看到的第二点

我看到的第二点，就是在 **各种抽象的过程中处理基本过程** ， 对 **复杂度可以很大** 的程序可以用 **主程序-(调用)->复杂过程处理程序-(调用)->主程序-...->（直到调用到简单处理程序)** 。这样一种处理的策略。

在上面的 *eval* 中，有一点很重要。 **就是不管是多么复杂的过程，追根结底也会到达基本过程** 。*eval* 只是构造了一个逻辑分配器，将基础的过程完成了，然后将复杂过程分配出去、或者分割成几个基础过程，分配出去的复杂过程最后再调用 *eval* 去解决更多嵌套的复杂/基础过程。

第三点就是安排好程序接口，让参数的传递尽量简洁明了。 ~~其实就是用来凑数的~~

好吧，还有一点就是，写程序的时候要注意到程序的易读性来进行抽象。有时候抽象太过会掩盖住程序主体的逻辑，而抽象太少又会让人很难看懂。这需要一个很精巧的度，也许只有不断地练习实践才能很好把握吧。我想这大概就是经验老道的程序员和我这种菜鸡之间的差距之一吧（笑）。

