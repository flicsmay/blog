##将语法分析与执行分离
我们看到前面描述过的解释器在每次执行的时候都要运行一次 `eval` 过程，也就是说每一次执行一个过程的时候都要去分析它的语法( `cond` 语句查找等等)，这样就会造成一种低效，因为我们完全没有必要再每次执行时都要去重新分析其语法结构，在编译过程（或第一次运行）的时候就可以重新组织其结构，之后就可以直接运行了（不用经过语法分析）。

####分析
我们可以看到在原先版本的 *eval-apply* 中 *apply* 函数体中对 *compound-procedure* 处理时用了 *eval-sequence*，也就是在拓展的环境下对整个函数体求值，这个求值当然效率不是那么高的。

我们可以想一种更好的方法吗？在定义函数时将分析过的函数体与函数名联系起来，也就是说储存在函数名中的 **不是纯文本类型** 的函数体。（也就是要经过查找、分析的函数体）而是一种 **可以直接执行的函数或者是易于转换成可执行的信息** 。这样，在调用函数的时候就可以减去不停的分析查找部分，提高效率。

在这里，作者用的就是 **直接储存函数体** 的方法，作者采用的取一个环境变量为参数的函数（我们可以在书上看到很多 *lambda (env)* ）作为变量名的函数体。这样在应用函数的时候只用将函数体应用上环境变量就行啦。于是在函数体里面有很多东西是需要环境变量来查找的，你在没有环境变量之前很可能不知道变量值是什么东西（全局变量）。于是这里将变量一层一层往下传，在 *analyze* 的分析子句中，就算是 *self-evaluating* 中都有一个空的 *lambda (env)* 外包装。

这些就是这个过程的基本思路。

在前面我们提到过，执行一条表达式就是在执行这条表达式的过程中，将遇到的变量全部替换成环境中的值，（因为应用参数的本质也是将变量绑定在环境中，至少这里是）当一个变量找不着时就产生一个运行错误。

所以书上的过程：

	(define (eval exp env)
	  ((analyze exp) env))

在最后 `analyze` 过程后只是取一个 `env` 作为参数，之后把 `env` 作为参数到处传也是出于此。

在 `analyze` 过程中是 **不能** 定义任何符号的，因为这需要一个给定的环境来支撑，同理在其中也不能应用实参（之后貌似还有补充）。但即使如此我们还是可以得到一定的收益，那么这些收益在哪里呢？

####原先版本
当我们定义一个函数，比如：

	(define (function x)
	  (if (= x 1)
	      1
	      0))

这时，原来的 *definition-value* 就会调用 *make-lambda* ，于是产生了 `'(lambda (x (if (= x 1) 1 0)))` 这个链表，也就是 *eval* 可以处理的形式，然后外层的 *eval* 将这个 *lambda* 式处理转化成一个 *procedure* 标签的形式。 最后 *define-varable* 就会将 *function* 和这个产生的过程联系起来，就是定义的全部过程。

每次当你要调用 *function* 的时候， *eval* 就会将 *function* 转化成 *procedure* 式，之后 *eval-sequence* 会对 *procedure* 式，也就是函数的主体进行分析，同时也是执行的过程。

以上表面了，在函数定义过程函数名调用返回的函数的主体**文本**，是需要进行分析才能执行的。所以说每次调用定义的函数时，都要对函数体进行一次分析，也就是效率低的原因。

####新版本
我们先看看旧版本和新版本的区别，姑且将新版的 *analyze* 等价为旧版的 *eval* ，可以看到， *definition-value* 将原式转化成可以被 *eval* 处理的 *lambda* 式之后，两者都对新生成的 *lambda* 式进行了分析将其转化成带 *'procedure* 标签的式子。这里就有差别了， **在原来的版本中，*eval* 是直接将 *lambda-body* 送入 *procedure* 中，而新版本中使用了 *analyze-sequence* 对 *lambda-body* 进行一次分析，然后送入。**

然后我们可以看见，在 *execute-application* 过程中，环境变量是直接作用于过程的，这是因为当你取出函数的时候就会返回一个只需要环境为变量的**函数**了。

####注意

这里要注意的一点就是这里的函数结构，在 *analyze-lambda* 中的 *make-procedure* 里面是没有传递 *env* 变量的，而在其它的过程中如 *if* 都会往后传递 *env* 变量。前者是为了在定义函数的时候不把环境变量传递而把整个函数体执行了。后者是因为函数体似乎只要一个环境变量就可以整个执行，因为可以一直传递下去。

这里有个地方就是在 *analyze-application* 中 *fporc* 在传递给 *execute-application* 之前应用了 *env* 变量。对于定义的函数和 *lambda* 式都是正确的，我不知道他是设计好的还是怎么样。