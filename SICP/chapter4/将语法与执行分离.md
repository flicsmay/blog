##将语法分析与执行分离
我们看到前面描述过的解释器在每次执行的时候都要运行一次 `eval` 过程，也就是说每一次执行一个过程的时候都要去分析它的语法( `cond` 语句查找等等)，这样就会造成一种低效，因为我们完全没有必要再每次执行时都要去重新分析其语法结构，在编译过程（或第一次运行）的时候就可以重新组织其结构，之后就可以直接运行了（不用经过语法分析）。

在前面我们提到过，执行一条表达式就是在执行这条表达式的过程中，将遇到的变量全部替换成环境中的值，（因为应用参数的本质也是将变量绑定在环境中，至少这里是）当一个变量找不着时就产生一个运行错误。

所以书上的过程：

	(define (eval exp env)
	  ((analyze exp) env))

在最后 `analyze` 过程后只是取一个 `env` 作为参数，之后把 `env` 作为参数到处传也是出于此。

在 `analyze` 过程中是 **不能** 定义任何符号的，因为这需要一个给定的环境来支撑，同理在其中也不能应用实参（之后貌似还有补充）。但即使如此我们还是可以得到一定的收益，那么这些收益在哪里呢？

####原先版本
当我们定义一个函数，比如：

	(define (function x)
	  (if (= x 1)
	      1
	      0))

这时，原来的 *definition-value* 就会调用 *make-lambda* ，于是产生了 `'(lambda (x (if (= x 1) 1 0)))` 这个链表，也就是 *eval* 可以处理的形式。最后 *define-varable* 就会将 *function* 和这个产生的过程联系起来，就是定义的全部过程。

每次当你要调用 *function* 的时候， *eval* 先将 *function* 替换成上面的 *lambda* 式，之后 *apply* 就会调用 *eval* 来分析 *lambda* 式，把 *lambda* 式转换成 *procedure* 的形式然后送去求值。

所以说每次调用定义的函数时，都要对函数体进行一次分析，也就是效率低的原因。

###新版本
定义函数时， *defineition-value* 产生一个 *lambda* 式: `(cons 'lambda (list 'x (list 'if (list '= 'x 1) 1 0)))` ，随后作为 *analyze* 的参数传递进去，结果就是 *analyze-lambda* 将调用的

	(lambda (env)
	  (if (true? (pproc env))
	      (cproc env)
	      (aproc env)))

整个函数的设计就是让 *env* 一直作为参数传递下去。于是放到这个具体的例子上就是:

	(lambda (env)
	  (if (true? (<search and apply '= pro>))
	      1
	      0))

















